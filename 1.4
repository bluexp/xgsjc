1.4软件工程
软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软件成本。IEEE对软件工程的定义是:将系统的、规范的、可度量的工程化方法应用于软件开发、运行和维护的全过程及上述方法的研究。
软件工程由方法、工具和过程三个部分组成。软件工程方法是完成软件工程项目的技术手段，它支持整个软件生命周期期;软件工程使用的工具是人们在开发软件的活动中智力和体力的扩展与延伸，它自动或半自动地支持软件的开发和管理，支持各种软件文档的生成;软件工程中的过程贯穿于软件开发的各个环节，管理人员在软件工程过程中要对软件开发的质量、进度、成本进行评估、管理和控制，包括人员组织、计划跟踪与控制、成本估估算、质量保证和配置管理等。
1.4.1需求分析
软件需求是指用户对新系统在功能、行为、性能、设计约束等方面的期望。根据IEEEE的软件工程标准词汇表，软件需求是指用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明。
1.需求的层次
简单地说，软件需求就是系统必须完成的事以及必须具备的品质。需求是多层次的，包括业务需求、用户需求和系统需求，这三个不同层次从目标到具体，从整体到局部，从概念到细节。
(1)业务需求。业务需求是指反映企业或客户对系统高层次的目标要求，通常来自项目投资人、购买产品的客户、客户单位的管理人员、市场营销部门或产品策划部门等。通过业务需求可以确定项目视图和范围，项目视图和范围文档把业务需求集中在一个简单、紧凑的文档中，该文档为以后的开发工作莫定了基础。
(2)用户需求。用户需求描述的是用户的具体目标，或用户要求系统必须能完成的任务。也就是说，用户需求描述了用户能使用系统来做些什么。通常采取用户访谈和问卷调查等方式，对用户使用的场景(scenarios)进行整理，从而建立用户需求。
(3)系统需求。系统需求是从系统的角度来说明软件的需求，包括功能需求、非功能需求和设计约束等。功能需求也称为行为需求，它规定了开发人员必须在系统中实现的软件功能，用户利用这些功能来完成任务，满足业务需要。功能需求通常是通过系统特性的描述表现出来的，所谓特性，是指一组逻辑上相关的功能需求，表示系统为用户提供某项功能(服务)，使用户的业务目标得以满足:非功能需求是指系统必须具备的属性或品质，又可细分为软件质量属性(例如，可维护性、可重用性、性能等)和其他非功能需求。设计约束也称为限制条件或补充规约，通常是对系统的一些约束说明，例如
必须采用国有自主知识产权的数据库系统，必须运行在UNIX操作系统之下等。
2.质量功能部暑
质量功能部署(Quality Function Deployment，QFD)是一种将用户要求转化成软件需求的技术，其目的是最大限度地提升软件工程过程中用户的满意度。为了达到这个目标，QFD将软件需求分为分别是常规需求、期望需求和意外需求。
(1)常规需求。用户认为系统应该做到的功能或性能，实现越多用户会越满意。
(2)期望需求。用户想当然认为系统应具备的功能或性能，但并不能正确描述自己想要得到的这些功能或性能需求。如果期望需求没有得到实现，会让用户感到不满意。
(3)意外需求。意外需求也称为兴奋需求，是用户要求范围外的功能或性能(但通常是软件开发人员很乐意赋予系统的技术特性)，实现这些需求用户会更高兴，但不实现也不影响其购买的决策。意外需求是控制在开发人员手中的，开发人员可以选择实现更多的意外需求，以便得到高满意、高忠诚度的用户，也可以(出于成本或项目周期的考虑)选择不实现任何意外需求。
3.需求获取
需求获取是一个确定和理解不同的项目干系人的需求和约束的过程。需求获取是件看上去很简单，做起来却很难的事情。需求获取是否科学、准备充分，对获取出来的结果影响很大，这是因为大部分用户无法完整地描述需求，而且也不可能看到系统的全貌。因此，需求获取只有与用户的有效合作才能成功。常见的需求获取方法包括用户访谈、问卷调查、采样、情节串联板、联合需求计划等。
4.需求分析
在需求获取阶段获得的需求是杂乱的，是用户对新系统的期望和要求，这些要求有重复的地方，也有矛盾的地方，这样的要求是不能作为软件设计的基础的。一个好的需求应该具有无二义性、完整性、一致性、可测试性、确定性、可跟踪性、正确性、必要性等特性，因此，需要分析人员把杂乱无章的用户要求和期望转化为用户需求，这就是需求分析的工作需求分析将提炼、分析和审查已经获取到的需求，以确保所有的项目干系人都明白其含义并找出其中的错误、遗漏或其他不足的地方。需求分析的关键在于对问题坡的研究与理解，为了便于理解问题域，现代软件工程方法所推荐的做法是对问题域进行抽象，将其分解为若干个基本元素，然后对元素之间的关系进行建模。
使用SA方法进行需求分析，其建立的模型的核心是数据字典，围绕这个核心，有三个层次的模型，分别是数据模型、功能模型和行为模型(也称为状态模型)。在实际工作中，一般使用实体联系图(E-R图)表示数据模型，用数据流图(Data Flow Diagram，DFD)表示功能模型，用状态转换图(State Transform Diagran，STD)表示行为模型。E-R图主要描述实体、属性，以及实体之间的关系:DFD从数据传递和加工的角度，利用图形符号通过逐层细分描述系统内各个部件的功能和数据在它们之间传递的情况，来说明系统所完成的功能:STD通过描述系统的状态和引起系统状态转换的事件，来表示系统的行为，指出作为特定事件的结果将执行哪些动作(例如，处理数据等)。
OOA的基本任务是运用O0方法，对问题域进行分析和理解，正确认识其中的事物及它们之间的关系，找出描述问题域和系统功能所需的类和对象，定义它们的属性和职责，以及它们之间所形成的各种联系。最终产生一个符合用户需求，并能直接反映问题域和系统功能的OOA模型及其详细说明。OOA模型包括用例模型和分析模型，用例是种描述系统需求的方法，使用用例的方法来描述系统需求的过程就是用例建模;分析模型描述系统的基本逻辑结构，展示对象和类如何组成系统(静态模型)，以及它们如何保持通信，实现系统行为(动态模型)。
5.软件需求规格说明书
软件需求规格说明书(Software Requirement Specification，SRS)是需求开发活动的产物，编制该文档的目的是使项目干系人与开发团队对系统的初始规定有一个共同的理解，使之成为整个开发工作的基础。SRS是软件开发过程中最重要的文档之一，对于任何规模和性质的软件项目都不应该缺少
在国家标准GBT8567-2006中，提供了一个SRS的文档模板和编写指南，其中规定SRS应该包括以下内容。
(1)范围。本部分包括SRS适用的系统和软件的完整标识，(若适用)包括标识号、标题、缩略词语、版本号和发行号;简述SRS适用的系统和软件的用途，描述系统和软件的一般特性;概述系统开发、运行和维护的历史:标识项目的投资方、需方、用户承建方和支持机构:标识当前和计划的运行现场:列出其他有关的文档:概述SRS的用途和内容，并描述与其使用有关的保密性和私密性的要求;说明编写SRS所依据的基线。
(2)引用文件。列出SRS中引用的所有文档的编号、标题、修订版本和日期，还应标识不能通过正常的供货渠道获得的所有文档的来源。
(3)需求。这一部分是SRS的主体部分，详细描述软件需求，可以分为以下项目:所需的状态和方式、需求概述、需求规格、软件配置项能力需求、软件配置项外部接口需求、软件配置项内部接口需求、适应性需求、保密性和私密性需求、软件配置项环境需求、计算机资源需求(包括硬件需求、硬件资源利用需求、软件需求和通信需求)、软件质量因素、设计和实现约束、数据、操作、故障处理、算法说明、有关人员需求、有关培训需求、有关后勤需求、包装需求和其他需求，以及需求的优先次序和关键程度。
(4)合格性规定。这一部分定义一组合格性的方法，对于第(3)部分中的每个需求，指定所使用的方法，以确保需求得到满足。合格性方法包括演示、测试、分析、宙查和特殊的合格性方法(例如，专用工具、技术、过程、设施和验收限制等)。
(5)需求可追踪性。这一部分包括从SRS中每个软件配置项的需求到其涉及的系统(或子系统)需求的双向可追踪性。
(6)尚未解决的问题。如果有必要，可以在这一部分说明软件需求中的尚未解决的遗留问题。
(7)注解。包含有助于理解SRS的一般信息，例如，背景信息、词汇表、原理等这一部分应包含为理解SRS需要的术语和定义，所有缩略语和它们在SRS中的含义的字母序列表。
(8)附录，提供那些为便于维护SRS而单独编排的信息(例如，图表、分类数据等)。
为便于处理，附录可以单独装订成册，按字母顺序编排。
另外，国家标准《计算机软件需求说明编制指南》(GBT9385-1988)也给出了个详细的SRS写作大纳，由于该标准年代久远，一些情况已经与现实不符，本书不再介绍。
6.需求验证
资深软件工程师都知道，当以SRS为基础进行后续开发工作，如果在开发后期或在交付系统之后才发现需求存在在问题，这时修补需求错误就需要做大量的工作。相对而言在系统分析阶段，检测SRS中的错误所采取的任何措施都将节省相当多的时间和资盒因此，有必要对于SRS的正确性性进行验证，以确保需求符合良好特特征。需求验证也称为需求确认，其活动是为了确定以下几个方面的内容。
(1)SRS正确地描述了预期的、满足项目干系人需求的系统行为和特征。
(2)SRS中的软件需求是从系统需求、业务规格和其他来源中正确推导而来的。
(3)需求是完整的和高质量的。
(4)需求的表示在所有地方都是一致的。
(5)需求为继续进行系统设计、实现和测试提供了足够的基础。
在实际工作中，一般通过需求评审和需求测试工作来对需求进行验证。需求评审就是对SRS进行技术评审，SRS的评审是一项精益求精的技术，它可以发现那些二义性的或不确定性的需求，为项目干系人提供在需求问题上达成共识的方法。需求的遗漏和错误具有很强的隐蔽性，仅仅通过阅阅读SRS，通常很难想象在特定环境下的系统行为。只有在业务需求基本明确，用户需求部分确定时，同步进行需求测试，才可能及早发现问题，从而在需求开发阶段以较低的代价解决这些问题。
7.UML
UML是一种定义良好、易于表达、功能强大且普遍适用的建模语言，它融入了软件工程领域的新思想、新方法和新技术，它的作用域不限于支持O0A和OOD，还支持从需求分析开始的软件开发的全过程从总体上来看，UML的结构包括构造块、规规则和公共机制三个部分。
构造块。UML有三种基本的构造块，分别是事物(thing)、关系(relationship和图(diagram)。事物是UML的重要组成部分，关系把事物紧密联系在一起，图是多个相互关联的事物的集合
规则。规则是构造块如何放在一起的规定，包括为构造块命名:给一个名字以特定含义的语境，即范围;怎样使用或看见名字，即可见性:事物如何正确、一致地相互联系，即完整性:运行或模拟动态模型的含义是什么，即执行。
公共机制。公共机制是指达到特定目标的公共UML方法，主要包括规格说明(详细说明)、修饰、公共分类(通用划分)和扩展机制四种。
1)UML中的事物
UML中的事物也称为建模元素，包括结构事物物(structural things)、行为事物(behavioral things，也称动作事物)、分组事物(grouping things)和注释事物(annotational things，也称注解事物)。这些事物是UML模型中最基本的OO构造块。
(1)结构事物:结构事物在模型中属于最静态的部分，代表概念上或物理上的元素。
UML有七种结构事物，分别是类、接口、协作、用例、活动类、构件和节点。
(2)行为事物:行为事物是UML模型中的动态部分，代表时间和空间上的动作UML有两种主要的行为事物。第一种是交互(内部活动)，交互是由一组对象之间在特定上下文中，为达到特定目的而进行的一系列消息交换而组成的动作。交互中组成动作的对象的每个操作都要详细列出，包括消息、动作次序(消息产生的动作)、连接(对象之间的连接);第二种是状态机，状态机由一系列对象的状态组成。
(3)分组事物:分组事物是UML模型中组织的部分，可以把它们看成是个盒子，模型可以在其中进行分解。UML只有一种分组事物，称为包。包是一种将有组织的元素分组的机制。与构件不同的是，包纯粹是一种概念上的事物，只存在于开发阶段段，而构件可以存在于系统运行阶段
4)注释事物:注释事物是UML模型的解释部分。
2)UML中的关系
UML用关系把事物结合在一起，主要有下列四四种关系
(1)依赖(dependency):依赖是两个事物之间的语义关系，其中一个事物发生变化会影响另一个事物的语义。
(2)关联(association):关联描述一组对象之间连接的结构关系。
(3)泛化(generalization):泛化是一般化和特殊化的关系，描述特殊元素的对象可替换一般元素的对象。
(4)实现( realization):实现是类之间的语义关系，其中的一个类指定了由另类保证执行的契约。
3)UML2.0中的图
UML2.0包括14种图，分别列举如下:
(1)类图(class diagram):类图描述一组类、接口、协作和它们之间的关系。在O0系统的建模中，最常见的图就是类图。类图给出了系统的静态设计视图，活动类的类图给出了系统的静态进程视图。
(2)对象图(object diagram):对象图描述一组对象及它们之间的关系。对象图描述了在类图中所建立的事物实例的静态快照。和类图一样，这些图给出系统的静态设计视图或静态进程视图，但它们是从真实案例或原型案例的角度建立的。
(3)构件图(component diagram):构件图描述一个封装的类和它的接口、端口以及由内嵌的构件和连接件构成的内部结构。构件图用于表示系统的静态设计实现视图。对于由小的部件构建大的系统来说，构件图是很重要的。构件图是类图的变体。
(4)组合结构图(composite structure diagram):组合结构图描述结构化类(例如构件或类)的内部结构，包括结构化类与系统其余部分的交互点。组合结构图用于画出结构化类的内部内容。
(5)用例图(use case diagram):用例图描述一组用例、参与者及它们之间的关系用例图给出系统的静态用例视图。这些图在对系统的行为进行组织和建模时是非常重要的。
(6)顺序图(sequence diagram，也称序列图):顺序图是一种交互图(interaction diagram)，交互图展现了一种交互，它由一组对象或参与者以及它们之间可能发送的消息构成。交互图专注于系统的动态视图。顺序图是强调消息的时间次序的交互图。
(7)通信图( communication diagram):通信图也是一种交互图，它强调收发消息的对象或参与者的结构组织。顺序图和通信图表达了类似的基本概念，但它们所强调的概念不同，顺序图强调的是时序，通信图强调的是对象之间的组织结构(关系)。在UML1.X版本中，通信图称为协作图(collaboration diagram)。
(8)定时图(timing diagram，也称计时图):定时图也是一种交互图，它强调消息跨越不同对象或参与者的实际时间，而不仅仅只是关心消息的相对顺序。
(9)状态图(state diagran):状态图描述一个状态机，它由状态、转移、事件和活动组成。状态图给出了对象的动态视图。它对于接口、类或协作的行为建模尤为重要，而且它强调事件导致的对象行为，这非常有助于对反应式系统建模。
(10)活动图(activity diagram):活动图将进程或其他计算结构展示为计算内部一步步的控制流和数据流。活动图专注于系统的动态视图。它对系统的功能建模和业务流程建模特别重要，并强调对象间的控制流程。
(11)部署图(deployment diagram):部署图描述对运行时的处理节点及在其中生存的构件的配置。部署图给出了架构的静态部署视图，通常一个节点包含一个或多个部。
(12)制品图(artifact diagram):制品图描述计算机中一个系统的物理结构。制品包括文件、数据库和类似的物理比特集合。制品图通常与部署图一起使用。制品也给出了它们实现的类和构件。
(13)包图( package diagram):包图描述由模型本身分解而成的组织单元，以及它们之间的依赖关系
14)交互概览图( interaction overview diagram):交互概览图是活动图和顺序图的混合物。
4)UML视图
UML对系统架构的定义是系统的组织结构，包括系统分解的组成部分，以及它们关联性、交互机制和指导原则等提供系统设计的信息。具体来说，就是指以下5个系统视图：
(1)逻辑辑视图:逻辑视图也称为设计视图，它表示了设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。
(2)进程视图:进程视图是可执行线程和进程作为活动类的建模，它是逻辑辑视图的次执行实例，描述了并发与同步结构。
(3)实现视图:实现视图对组成基于系统的物理代码的文件和构件进行建模。
(4)部署视图:部署视图把构件部署到一组物理节点上，表示软件到到硬件的映射和分布结构。
(5)用例视图:用例视图是最基本的的需求分析模型。
另外，UML还允许在一定的阶段隐藏模型的某些元素、遗漏某些元素，以及不保证模型的完整性，但模型逐步地要达到完整和一致。
8.面向对象分析
OOA的基本任务是运用OO方法，对问题域进行分析和理解，正确认识其中的事物及它们之间的关系，找出描述问题域和系统功能所需的类和对象，定义它们的属性和职责，以及它们之间所形成的各种联系。最终产生一个符合用户需求，并能直接反映问题域和系统功能的OOA模型及其详细说明OOA模型独立于具体实现，即不考虑与系统具体实现有关的因素，这也是OOA和OOD的区别之所在。OOA的任务是“做什么”，OOD的任务是“怎么做”面向对象分析阶段的核心工作是建立系统的用例模型与分析模型。
1)用例模型
SA(结构化分析)方法采用功能分解的方式来描述系统功能，在这种表达方式中统功能被分解到各个功能模块中，通过描述细分的系统模块的功能来达到描述整个系统功能的目的。采用SA方法来描述系统需求，很容易混淆需求和设计的界限，这样的描述实际上已经包含了部分的设计在内。因此，系统分析师常感到迷感，不知道系统需求应该详细到何种程度。一个极端的做法就是将需求详细到概要设计，因为这样的需求描述既包含了外部需求也包含了内部设计。SA方法的另一个缺点是分割了各项系统功能的应用环境，从各项功能项入手，很难了解到这些功能项如何相互关联来实现一个完整的系统服务的。
从用户的角度来看，他们并不想了解系统的内部结构和设计，他们所关心的是系统所能提供的服务，这就是用例方法的基本思想。用例方法是一种需求合成技术，先获取需求，记录下来，然后从这些零散的要求和期望中进行整理与提炼，从而建立用例模型。在OOA方法中，构建用例模型一般需要经历四个阶段，分别是识别参与者、合并需求获得用例、细化用例描述和调整用例模型，其中前三个阶段是必需的。
1)识别参与者:参与者是与系统交互的所有事物，该角色不仅可以由人承担，还可以是其他系统和硬件设备，甚至是系统时钟。参与者一定在系统之外，不是系统的部分，可以通过下列问题来帮助系统分析师发现系统的参与者:谁使用这个系统？谁安装这个系统？谁启动这个系统？谁维护这个系统？谁关闭这个系统？哪些(其他的)系统使用这个系统？谁从这个系统获取信息?谁为这个系统提供信息？是否有事情自动在预计的时间发生？
(2)合并需求获得用例:将参与者都找到之后，接下来就是仔细地检查参与者，为每一个参与者确定用例，首先，要将获取到的需求分配给与其相关的参与者，以便可以针对每个参与者进行工作，而无遗满:其次，进行合并操作。在合并之前，要明确为什么要合并，知道了合并的目的，才可能选择正确的合并操作。合并后，将产生用例，将识别到的参与者和合并生成的用例，通过用例图的形式整理出来，以获得用例模型的框架。
(3)细化用例描述:用例建模的主要工作是书写用例规约(use case specificatio而不是画图。用例模板为一个给定项目的所有人员定义了用例规约的结果，其内容至少包括用例名、参与者、目标、前置条件、事件流(基本事件流和扩展事件流)和后置条件等，其他的还可以包括非功能需求和用例优先级等。
(4)调整用例模型:在建立了初步的用例模型后，还可以利用用例之间的关系来调整用例模型。用例之间的关系主要有包含、扩展和泛化，利用这些关系，把一些公共的信息抽取出来，以便于复用，使得用例模型更易于维护。
包含关系。当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示它们。其中这个提取出来的公共用例称为抽象用例，而把原始用例称为基本用例或基础用例。
扩展关系。如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，这样使描述可能更加清晰。
泛化关系。当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系。
2)分析模型
前文从用户的观点对系统进行了用例建模，但捕获了用例并不意味着分析的结束还要对需求进行深入分析，获取关于问题域本质内容的分析模型。分析模型描述系统的基本逻辑结构，展示对象和类如何组成系统(静态模型)，以及它们如何保持通信，实现系统行为(动态模型)。
为了使模型独立于具体的开发语言，系统分析师需要把注意力集中在概念性问题上而不是软件技术问题上，这些技术的起点就是领域模型。领域模型又称为概念模型或简称为域模型，也就是找到那些代表事物与概念的对象，即概念类。概念类可以从用例模型中获得灵感，经过完善将形成分析模型中的分析类。每一个用例对应一个类图，描述参与这个用例实现的所有概念类，而用例的实现主要通过交互图来表示。例如，用例的事件流会对应产生一个顺序图，描述相关对象如何通过合作来完成整个事件流，复杂的备选事件流也可以产生一个或多个顺序图。所有这些图的集合就构成了系统的分析模型。
建立分析模型的过程大致包括定义概念类、确定类之间的关系、为类添加职责、建立交互图等，其中有学者将前三个步骤统称为CRC(Class- Responsibility- Collaborator类-责任-协作者)建模类之间的主要关系有关联、依赖、泛化、聚合、组合和实现等，它们在UML中的表示方式，如图1-10所示（图暂缺）
(1)关联关系。关联提供了不同类的对象之间的结构关系，它在一段时间内将多个类的实例连接在一起。关联体现的是对象实例之间的关系，而不表示两个类之间的关系其余的关系涉及类元自身的描述，而不是它们的实例。对于关联关系的描述，可以使用关联名称、角色、多重性和导向性来说明。
(2)依赖关系。两个类A和B，如果B的变化可能会引起起A的变化，则称类A依赖于类B，依赖可以由各种原因引起，例如，一个类向另一个类发送消息、一个类是另个类的数据成员、一个类是另一个类的某个操作参数等。
(3)泛化关系。泛化关系描述了一般事物与该事物中的特殊种类之间的关系，也就是父类与子类之间的关系。继承关系是泛化关系的反关系，也就是说，子类继承了父类，而父类则是子类的泛化。
(4)共享聚集。共享聚集关系通常简称为聚合关系，它表示类之间的整体与部分的关系，其含义是“部分”可能同时属于多个“整体”，“部分”与“整体”的生命周期可以不相同。例如，汽车和车轮就是聚合关系，车子坏了，车轮还可以用:车轮坏了，可以再换一个新的。
(5)组合聚集。组合聚集关系通常简称为组合关系，它也是表示类之间的整体与部分的关系。与聚合关系的区别在于，组合关系中的“部分”只能属于一个“整体”，“部分”与“整体”的生命周期相同，“部分”随着“整体”的创建而创建，也随着“整体”的消亡而消亡。例如，一个公司包含多个部门，它们之间的关系就是组合关系。公司旦倒闭，也就没有部门了。
(6)实现关系。实现关系将说明和实现联系起来。接口是对行为而非实现的说明，而类中则包含了实现的结构。一个或多个类可以实现一个接口，而每个类分别实现接口中的操作。




1.4.2软件架构设计
软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构件的描述、构构件的相互作用(连接件)、指导构件集成的模式以及这些模式的约束组成。软件架构不仅指定了系统的组织结构和拓扑结构，并且显示了系统需求和构件之间的对应关系，提供了一些设计决策的基本原理。
软件架构虽脱胎于软件工程，但其形成同时借鉴了计算机架构和网络架构中很多宝贵的思想和方法。近年来，软件架构已完全独立于软件工程，成为计算机科学的一个最新的研究方向和独立学科分支，软件架构研究的主要内容涉及软件架构描述、软件架构风格、软件件架构评估和软件架构的形式化方法等，解决好软件的复用、质量和维护问题是研究软件架构的根本目的。
1.软件架构风格
软件架构设计的一个核心问题是能否达到架构级的软件复用，也就是说，能否在不同的系统中，使用同一个软件架构。软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式(idiomatic paradigm)，架构风格定义了一个系统“家族”，即一个架构定义、一个词汇表和一组约束。词汇表中包含一些构件和连接件类型，而约束指出系统是如何将这些构件和连接件组合起来的。架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个构件有效地组织成一个完整的系统。
Garan和Shaw对通用软件架构风格进行了分类，他们将软件架构分为数据流风格调用运回风格、独立构件风格、虚拟机风格和仓库风格。
(1)数据流风格:数据流风格包括批处理序列和管道/过滤器两种风格
(2)调用返回风格:调用返回风格包括主程序/子程序、数据抽象和面向对象，以及层次结构。
(3)独立构件风格:独立构件风格包括进程通信和事件驱动的系统。
(4)虚拟机风格:虚拟机风格包括解释器和基于规则的系统。
(5)仓库风格:仓库风格包括数据库系统、黑板系统和超文本系统。
2.软件架构评估
软件架构设计是软件开发过程中关键的一步。对于当今世界上庞大而复杂的系统来说，没有一个合适的架构而要有一个成功的软件设计几乎是不可想象的。不同类型的系统需要不同的架构，甚至一个系统的不同子系统也需要不同的架构。架构的选择往往会成为一个系统设计成败的关健。但是，怎样才能知道为系统所选用的架构是恰当的呢?如何确保按照所选用的架构能顺利地开发出成功的软件产品呢?要回答这些问题并不容易，因为它受到很多因素的影响，需要专门的方法来对其进行评估。软件架构评估可以只针对一个架构，也可以针对一组架构。在架构评估过程中，评估人员所关注的是系统的质量属性。
在分析具体架构评估方法之前，我们先来了解两个概念，分别是敏感点(sensitivitypoin)和权衡点(tradeoff point)，敏感点是一个或多个构件(和或构件之间的关系)的特性，权衡点是影响多个质量属性的特性，是多个质量属性的敏感点。例如，改变加密级别可能会对安全性和性能产生非常重要的影响。提高加密级别可以提高安全性，但可能要耗费更多的处理时间，影响系统性能，如果某个机密消息的处理有严格的时间延迟要求，则加密级别可能就会成为一个权衡点。
从目前已有的软件架构评估技术来看，可以归纳为三类主要的评估方式，分别是基于调查问卷(或检查表)的方式、基于场景的方式和基于度量的方式。这三种评估方式中，基于场景的评估方式最为常用。
基于场景的方式主要包括:架构权衡分析法(Architecture Tradeoff Analysis Method，ATAM)、软件件架构分析法(Software Architecture Analysis Method，SAAM)和成本效益分析法( Cost Benefit Analysis Method，CBAM)中。在架构评估中，一般采用刺激(stimulus)、环境(environment)和响应(response)三方面来对场景进行描述。刺激是场景中解释或描述项目干系人怎样引发与系统的交互部分，环境描述的是刺激发生时的情况，响应是指系统是如何通过架构对刺激作出反应的。
基于场景的方式分析软件架构对场景的支持程度，从而判断该架构对这一场景所代表的质量需求的满足程度。例如，用一系列对软件的修改来反映易修改性方面的需求，用一系列攻击性操作来代表安全性方面的需求等。这一评估方式考虑到了所有与系统相关的人员对质量的要求，涉及的基本活动包括确定应用领域的功能和软件架构之间的映射，设计用于体现待评估质量属性的场景，以及分析软件架构对场景的支持程度。
不同的系统对同一质量属性的理解可能不同，例如，对操作系统来说，可移植性被理解为系统可在不同的硬件平台上运行，而对于普通通的应用系统而言，可移植性往往是指该系统可在不同的操作系统上运行。由于存在这种不一致性，对一个领域适合的场景设计在另一个领域内未必合适，因此，基于场景的评估方式是特定于领域的。这一评估方式的实施者一方面需要有丰富的领域知识，以对某一质量需求设计出合理的场景;另方面，必须对待评估的软件架构有一定的了解，以准确判断它是否支持场景描述的系列活动。
1.4.3 软件设计
软件设计是需求分析的延伸与拓展。需求分析阶段解决“做什么”的问题，而软件设计阶段解决“怎么做”的问题。同时，它也是系统实施的基础，为系统实施工作做好铺垫。合理的软件设计方案既可以保证系统的质量，也可以提高开发效率，确保系统实施工作的顺利进行。从方法上来说，软件设计分为结构化设计与面向对象设计。
1.结构化设计
SD是一种面向数据流的方法，它以SRS和SA阶段所产生的DFD和数据字典等文档为基础，是一个自顶向下、逐步求精和模块化的过程。SD方法的基本思想是将软件设计成由相对独立且具有单一功能的模块组成的结构，分为概要设计和详细设计两个阶段，其中概要设计又称为总体结构设计，它是开发过程中很关键的一步，其主要任务是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成软件的模块结构图，即系统结构图。在概要设计中，将系统开发的总任务分解成许多个基本的、具体的任务，而为每个具体任务选择适当的技术手段和处理方法的过程称为详细设计。根据任务的不同，详细设计又可分为多种，例例如，输入/输出设计、处理流程设计、数据存储设计、用户界面设计、安全性和可靠性设计等。
在SD中，需要遵循一个基本的原则:高内聚，低耦合。内聚表示模块内部各成分之间的联系程度，是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做目标单一的一件事情;耦合表示模块之间联系的程度。紧密耦合表示模块之间联系非常强，松散耦合表示模块之间联系比较弱，非耦合则表示模块之间无任何联系，是完全独立的。
2.面向对象设计
OOD是OOA方法的延续，其基本思想包括抽象、封装和可扩展性，其中可扩展性主要通过继承和多态来实现。在OOD中，数据结构和在数据结构上定义的操作算法封装在一个对象之中。由于现实世界中的事物都可以抽象出对象的集合，所以OOD方法是一种更接近现实世界、更自然的软件设计方法OOD的主要任务是对类和对象进行设计，包括类的属性、方法，以及类与类之间的关系。OOD的结果就是设计模型。对于OOD而言，在支持可维护性的同时，提高软件的可复用性是一个至关重要的问题，如何同时提高软件的可维护性和可复用性，是OOD需要解决的核心问题之一。在OOD中，可维护性的复用是以设计原则为基础的。常用
的OOD原则如下：
(1)单一职责原则:设计功能单一的类。本原则与结构化方法的高内聚原则是一致的
(2)开放-封闭原则:对扩展开放，对修改封闭。
(3)李氏(Liskov)替换原则:子类可以替换父类。
4)依赖倒置原则:要依赖于抽象，而不是具体实现;针对接口编程，不要针对实现编程。
(5)接口隔离原则:使用多个专门的接接口比使用单一的总接口要好。
(6)组合重用原则:要尽量使用组合，而不是继承关系达到重用目的
(7)迪米特(Demeter)原则(最少知识法则):一个对象应当对其他对象有尽可能少的了解。本原则与结构化方法的低耦合原则是一致的
3.设计模式
设计模式是前人经验的总结，它使人们可以方便地复用成功的软件设计。当人们在特定的环境下遇到特定类型的问题，采用他人已使用过的一些成功的解决方案，一方面可以降低分析、设计和实现的难度，另一方面可以使系统具有更好的可复用性和灵活性设计模式包含模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式等基本要素
根据处理范围不同，设计模式可分为类模式和对象模式。类模式处理类和子类之间的关系，这些关系通过继承建立，在编编译时刻就被确定下来，属于静态关系;对象模式处理对象之间的关系，这些关系在运行时刻变化，更具动态性。
根据目的和用途不同，设计模式可分为创建型( Creational)模式、结构型(Structural)模式和行为型(Behavioral)模式三种。创建型模式主要用于创建对象，包括工厂方法模式、抽象工厂模式、原型模式、单例模式和建造者模式等;结构型模式主要用于处理类或对象的组合，包括适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模
式和代理模式等;行为型模式主要用于描述类或对象的交互以及职责的分配，包括职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式等。
1.4.4 软件工程的过程管理
在无规则和混乱的管理条件下，先进的软件开发技术和工具并不能发挥应有的作用。于是，人们认识到，改进软件过程的管理是解决上述难题的突破口。但是，各个软件组织的过程成熟度有着较大的差别。为了做出客观、公正的比较，就需要建立一种衡量的标准。使用此标准一方面可以评价软件开发方的质量保证能力，在软件项目评标活动中选择开发方:另一方面，该标准也必然成为软件组织加强质量管理和提高软件产品质量的依据。
软件过程是软件生命周期中的一系列相关活动，即用于开发和维护软件及相关产品的一系列活动。软件产品的质量取决于软件过程，具有良好软件过程的组织能够开发出高质量的软件产品。在软件过程管理方面，最著名的是能力成熟度模型集成(Capability Maturity model integration，CMMI)，它融合了多种模型，形成了组织范围内过程改进的单一集成模型，其主要目的是消除不同模型之间的不一致和重复，降低基于模型进行改进的成本。CMMI继承了CMM的阶段表示法和 EIAIS731的连续式表示法。这两种表示方法各有优缺点，均采用统一的24个过程域，它们在逻辑上是等价的，对同一个组织采用两种模型分别进行CMMI评估，得到的结论应该是相同的。
(1)阶段式模型。阶段式模型基本沿袭CMM模型框架，仍保持4个成熟等级，但关键过程域做了一些调整和扩扩充，如表1-2所示

表1-2过程域的阶段式分组
成熟度等级	过程域
可管理级	需求管理、项目计划、配置管理、项目监督与控制、供应商合同管理理、度量和分析、过程和产品质量保证
已定义级	需求开发、技术解决方案、产品集成、验证、确认、组织级过程焦点、组织级过程定义、组织级培训、集成项目管理、风险管理、集成化的团队、决策分析和解决方
案、组织级集成环境
量化管理级	组织级过程性能、定量项目管理
优化管理级	组织级改革与实施、因果分析和解决方案

当组织通过了某一等级过程域中的全部过程，即意味着该组织的成熟度达到了这一等级。利用阶段式模型对组织进行成熟度度量，概念清晰、易于理解、便于操作。
(2)连续式模型。与阶段式模型相比，连续式模型没有与组织成熟度相关的几个阶段。连续式模型将24个过程域按照功能划分为过程管理、项目管理、工程和支持四个过程组。每组包含的过程域如表1-3所示
表1-3连续式模型的过程域分组
连续式分组	过程域
过程管理	组织级过程焦点、组织级过程定义、组织级培训、组织级过程性能、组织级改革与实施
项目管理	项目计划、项目监督与控制、供应商合同管理、集成项目管理、风险管理、集成化的团队、定量项目管理
工程	需求开发、技术解决方案、产品集成、验证、确认
支持	配置管理、度量和分析、过程和产品质量保证、决策分析和解决方案、组织级集成环境、因果分析和解决方案



1.4.5软件测试及管理
软件测试是在将软件交付给客户之前所必须完成的重要步骤。目前，软件的正确性证明尚未得到根本的解决，软件测试仍是发现软件错误(缺陷)的主要手段。根据国家标准《计算机软件测试规范范(GB/T15532-2008)》，软件测试的日的是验证软件是否满足软件开发合同或项目开发计划、系统/子系统设计文档、SRS、软件设计说明和软件产品说明等规定的软件质量要求。通过测试，发现软件缺陷，为软件产品的质量测量和评价提供依据。
GB/T15532-2008还规定了测试用例设计原则和测试用例要素。其中，测试用例设计的原则有基于测试需求的原则、基于测试方法的原则、兼顾测试充分性和效率的原则、测试执行的可再现性原则:每个测试用例应包括名称和标识、测试追踪、用例说明、测试的初始化要求、测试的输入、期望的测试结果、评价测试结果的准则、操作过程、前提和约束、测试终止条件。
1.测试的方法
软件测试方法可分为静态测试和动态测试。静态测试是指被测试程序不在机器上运行，而采用人工检测和计算机辅助静态分析的手段对程序进行检测。静态测试包括对文档的静态测试和对代码的静态测试。对文档的静态测试主要以检查单的形式进行，而对代码的静态测试一般采用桌前检查(Desk Checking)、代码走查和代码审查。经验表明使用这种方法能够有效地发现30%-70%的逻辑设计和编码错误。
动态测试是指在计算机上实际运行程序进行软件测试，一般采用白盒测试和黑盒测试方法。白盒测试也称为结构测试，主要用于软件单元测试中。它的主要思想是，将程序看作是一个透明的白盒，测试人员完全清楚程序的结构和处理算法，按照程序内部逻辑结构设计测试用例，检测程序中的主要执行通路是否都能按预定要求正确工作。白盒测试方法主要有控制流测试、数据流测试和程序变异测试等。另外，使用静态测试的方法也可以实现白盒测试，例如，使用人工检查代码的方法来检查代码的逻辑问题题，也属于白盒测试的范畴。白盒测试方法中，最常用的技术是逻辑覆盖，即使用测试数据运行被测程序，考察对程序逻辑的覆盖程度。主要的覆盖标准有语句覆盖、判定覆盖、条件覆盖、条件/判定覆盖、条件组合覆盖、修正的条件/判定覆温和路径覆盖等。
黑盒测试也称为功能测试，主要用于集成测试、确认测试和系统测试中。黑盒测试将程序看作是一个不透明的黑盒，完全不考虑(或不了解)程序的内部结构和处理算法而只检查程序功能是否能按照SRS的要求正常使用，程序是否能适当地接收输入数据并产生正确的输出信息，程序运行过程中能否保持外部信息(例如，文件和数据库等)的完整性等，黑盒测试根据SRS所规定的功能来设计测试用例，一般包括等价类划分、边界值分析、判定表、因果图、状态图、随机测试、猜错法和正交试验法等。
2，测试的类型
根据国家标准GB/T15532-2008，软件测试可分为单元测试、集成测试、确认测试、系统测试、配置项测试和回归测试等类别。
(1)单元测试。单元测试也称为模块测试，测试的对象是可独立编译或汇编的程序模块、软件构件或OO软件中的类(统称为模块)，其目的是检查每个模块能否正确地实现设计说明中的功能、性能、接口和其他设计约束等条件，发现模块内可能存在的各种差错。单元测试的技术依据是软件详细设计说明书，着重从模块接口、局部数据结构、重要的执行通路、出错处理通路和边界条件等方面对模块进行测试
(2)集成测试。集成测试的目的是检查模块之间，以及模块和已集成的软件之间的接口关系，并验证已集成的软件是否符合设计要求。集成测试的技术依据是软件概要设计文档。除应满足一般的测试准入条件外，在进行集成测试前还应确认待测试的模块均已通过单元测试。
(3)确认测试。确认测试主要用于验证软件的功能、性能和其他特性是否与用户需求一致，根据用户的参与程度，通常包括以下类型内部确认测试。
	内部确认测试。主要由软件开发组织内部按照SRS进行测试。
	Alpha测试和Beta测试。对于通用产品型的软件开发而言，Alpha测试是指由用户在开发环境下进行测试，通过Apha测试以后的产品通常称为 Alpha版;Beta测试是指由用户在实际使用环境下进行测试，通过Beta测试的产品通常称为Beta版。一般在通过Beta测试后，才能把产品发布或交付给用户验收测试。验收测试是指针对SRS，在交付前以用户为主进行的测试。其测试对象为完整的、集成的计算机系统。验收测试的目的是，在真实的用户工作环境下，检验软件系统是否满足开发技术合同或SRS。
	验收测试的结论是用户确定是否接收该软件的主要依据。除应满足一般测试的准入条件外，在进行验收测试之前，应确认被测软件系统已通过系统测试。
(4)系统测试。系统测试的对象是完整的、集成的计算机系统，系统测试的目的是在真实系统工作环境下，验证完整的软件配置项能否和系统正确连接，并满足系统子系统设计文档和软件开发合同规定的要求。系统测试的技术依据是用户需求或开发合同除应满足一股测试的准入条件外，在进行系统测试前，还应确认被测系统的所有配置项已通过测试，对需要固化运行的软件还应提供固件。一般来说，系统测试的主要内容包括功能测试、健壮性测试、性能测试、用户界面测试、安全性测试、安装与反安装测试等，其中，最重要的工作是进行功能测试与性能测试。功能测试主要采用黑盒测试方法性能测试主要验证软件系统在承担一定负载的情况下所表现出来的特性是否符合客户的需要，主要指标有响应时间、吞吐量、并发用户数和资源利用率等。
(5)配置项测试。配置项测试的对象是软件配置项，配置项测试的目的是检验软件配置项与SRS的一致性。配置项测试的技术依据是SRS(含接口需求规格说明)。除应满足一般测试的准入条件外，在进行配置项测试之前，还应确认被测软件配置项已通过单元测试和集成测试。
(6)回归测试。回归测试的目的是测试软件变更之后，变更更部分的正确性和对变更需求的符合性，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性。回归测试的对象主要包括以下四个方面。
	未通过软件单元测试的软件，在变更之后，应对其进行单元测试。
	未通过配置项测试的软件，在变更之后，首先应对变更的软件单元进行测试，然后再进行相关的集成测试和配置项测试。
	未通过系统测试的软件，在变更之后，首先应对变更的软件单元进行测试，然后再进行相关的集成测试、配置项测试和系统测试。
	因其他原因进行变更之后的软件单元，也首先应对变更的软件单元进行测试，然后再进行相关的软件测试。
3.面向对象的测试
O0系统的测试目标与传统信息系统的测试目标是一致的，但OO系统的测试策略与传统的结构化系统的测试策略有很大的不同，这种不同主要体现在两个方面，分别是测试的焦点从模块移向了类，以及测试的视角扩大到了分析和设计模型。
与传统的结构化系统相比，OO系统具有三个明显特征，即封装性、继承性与多态性。正是由于这三个特征，给O0系统的测试带来了一系列的困难。封装性决定了OO0系统的测试必须考虑到信息隐蔽原则对测试的影响，以及对象状态与类的测试序列:继承性决定了OO系统的测试必须考虑到继承对测试充分性的影响，以及误用引起的错误多态性决定了O0系统的测试必须考虑到动态绑定对测试充分性的影响、抽象类的测试，以及误用对测试的影响。
4.软件调试
软件调试(排错)与成功的测试形影相随。测试成功的标志是发现了错误，根据错误迹象确定错误的原因和准确位置，并加以改正，主要依靠软件调试技术。软件调试是个相当艰苦的过程，究其原因，除了开发人员心理方面的障碍外，还因为隐藏在程序中的错误具有下列特殊的性质。
(1)错误的外部征兆远离引起错误的内部原因，对于高度耦合的程序结构象更为严重。
(2)纠正一个错误造成了另一个错误现象(暂时)的消失。
(3)某些错误征兆只是假象。
(4)因操作人员一时疏忽造成的某些错误征兆不易追踪。
(5)错误是由于分时而不是程序引起的。
(6)输入条件难以精确地再构造(例如，某些实时应用的输入次序不确定)。
(7)错误征兆时有时无，此现象对嵌入式系统尤其普遍。
(8)错误是由于把任务分布在若干台不同处理机上运行而造成的。
尽管软件调试不是一门好学的技术，但还是有若干行之有效的方法和策略的，常用的软件调试策略可以分为蛮力法、回溯法和原因排除法三类。软件调试与测试的区别主要体现在以下几个方面。
(1)测试的目的是找出存在的错误，而调试的目的是定位错误并修改程序以修正错误。
(2)调试是测试之后的活动，测试和调试在目标、方法和思路上都有所不同。
(3)测试从一个已知的条件开始，使用预先定义的过程，有预知的结果;调试从个未知的条件开始，结束的过程不可预计。
(4)测试过程可以事先设计，进度可以事先确定:调试不能描述过程或持续时间。
5.软件测试试管理
软件测试的管理包括过程管理、配置管理和评审工作。
(1)过程管理。过程管理包括测试活动管理和测试资源管理。软件测试应由相对独立的人员进行。根据软件项目的规模、完整性级别和测试类别，软件测试可由不同机构组织实施。一般情况下，软件测试人员应包括测试项目负责人、测测试分析员、测试设计员、测试程序员、测试员、测试系统管理员和配置管理员等。
开始软件测试工作，一般应具备下列条件(准入条件):具有测试合同(或项日计划);具有软件件测试所需的各种文档:所提交的被测软件已受控;软件源代码已正确通过编译或汇编。
结束软件测试工作，一般应达到下列条件(准出条件):已按要求完成了合同(或项目计划)所规定的软件测试任务:;实际测试过程遵循了原定的软件测试计划和软件测试说明;客观、详细地记录了软件测试过程和软件测试中发现的所有问题:软件测试文档齐全，符合规范;软件测试的全过程自始至终在控制下进行:软件测试中的问题或异常有合理解释或正确有效的处理;软件测试工作通过了测试评审;全部测试工具、被测软件、测试支持软件和评审结果已纳入配置管理。
(2)配置管理。应按照软件配置管理的要求，将测试过程中产生的各种工作产品纳入配置管理。由开发组织实施的软件测试，应将测试工作产品纳入软件项目的配置管理由独立测试组织实施的软件测试，应建立配置管理库，将被测试对象和测试工作产品纳入配置管理。
(3)评审。测试过程中的评审包括测试就绪评审和测试评审。测试就绪评审是指在测试执行前对测试计划和测试说明等进行评审，评审测试计划的合理性和测试用例的正确性、完整性和覆盖充分性，以及测试组织、测试环境和设备、工具是否齐全并符合技术要求等:测试评审是指在测试完成后，评审测试过程和测试结果的有效性，确定是否达到测试目的，主要对测试记录和测试报告进行评审。








1.4.6软件集成技术
在企业信息化建设的过程中，由于缺乏统一规划和总体布局，往往形成多个信息孤岛。信息孤岛使数据的一致性无法得到保证，信息无法共享和反馈，需要重复多次的采集和输入。信息孤岛是企业信息化一个重要的负面因素，其主要原因既有技术因素也有管理因素，还有业务流程和标准方面的因素。如何将众多的信息孤岛联系起来，以便让不同的系统之间交互信息，是当前很多企业都面临的一个问题。
此时集成技术应运而生，集成包括软硬件以及网络的集成，在本节我们们主要介绍软件层次的集成技术一一企业应用集成( Enterprise application integration，EAI)。
企业应用集成技术可以消除信息孤岛，它将多个企业信息系统连接起来，实现无缝集成，使它们就像一个整体一样。EAI是伴随着企业信息系统的发展而产生和演变的企业的价值取向是推动EAI技术发展的原动力，而EAI的实现反过来也驱动企业竞争优势的提升。
EAI所连接的应用包括各种电子商务系统、ERP、CRM、SCM、OA、数据库系统和数据仓库等。从单个企业的角度来说，EAI可以包括表示集成、数据集成、控制集成和业务流程集成等多个层次和方面。当然，也可以在多个企业之间进行应用集成。
1.表示集成
表示集成也称为界面集成，这是比较原始和最浅层次的集成，但又是常用的集成。这种方法将用户界面作为公共的集成点，把原有零散的系统界面集中在一个新的界面中其模型，如图1-11所示（图暂时省略，以后更新的时候会补上）。
表示集成是黑盒集成，无须了解程序与数据库的内部构造。常用的集成技术主要有屏幕截取和输入模拟技术。表示集成通常应用于以下几种情况。
(1)在现有的基于终端的应用系统上配置基于PC( Personal computer，个人计算机)的用户界面。
(2)为用户提供一个看上去统一,但是由多个系统组成的应用系统。
(3)当只有可能在显示界面上实现集成时。

从图1-11中可以看出,表示集成的实现是很简单的,也是很不彻底的,只是做了层“外装修”,而额外多出来的集成界面也将可能成为系统的性能瓶颈。
2.数据集成
为了完成控制集成和业务流程集成,必须首先解决数据和数据库的集成问题。在集成之前,必须首先对数据进行标识并编成目录,另外还要确定元数据模型,保证数据在数据库系统中分布和共享。因此,数据集成是白盒集成,其模型如图1-12所示（图暂时省略，以后更新的时候会补上）。
有很多不同的中间件工具可以用于数据集成。例如,批量文件传输,即以特定的或是预定的方式在原有系统和新开发的应用系统之间进行文件丰传输:用于访问不同类型数据库系统的ODBC( Open Database Connectivity,开放数据库互连)标准接口:向分布式数据库提供连接的数据库访问中间件技术等。通常在以下情况下,将会使用数据集成
(1)需要对多种信息源产生的数据进行综合分析和决策。
(2)要处理一些多个应用喜人需要访问的公用信息库。
(3)当需要从某数据源获得数据来更新另一个数据源时,特别是它们之间的数据格式不相同时。
相对而言,数据集成比表示集成要更加灵活。但是,当业务逻辑经常发生变化时数据集成就会面临困难。
3.控制集成
控制集成也称为功能集成或应用集成,是在业务逻辑层上对应用系统进行集成的控制集成的集成点存于程序代码中,集成处可能只需简单使用公开的API( ApplicationProgramming interface,应用程序编程接口)就可以访问,当然也可能需要添加附加的代码来实现。控制集成是黑盒集成,其模型如图1-13所示（图暂时省略，以后更新的时候会补上）。
实现控制集成时,可以借助于远程过程调用或远程方法调用、面向消息的中间件、分布式对象技术和事务处理监控器来实现。控制集成与表示集成、数据集成相比,灵性更高。表示集成和数据集成适用的环境下,都适用于控制集成。但是,由于控制是在业务逻辑层进行的,其复杂度更高一些。而且,很多系统的业务逻辑部分并没有提供API,这样,集成难度就会更大。
4.业务流程集成
业务流程集成也称为过程集成,这种集成超越了数据和系统,它由一系列基于标准的、统一数据格式的工作流组成。当进行业务流程集成时,企业必须对各种业务信息的交换进行定义、授权和管理,以便改进操作、减少成本、提高响应速度
业务流程集成不仅要提供底层应用支撑系统之间的互连,同时要实现存在于企业内部的应用之间,木企业和其他合作伙伴之间的端到端的业务流程的管理,它包括应用集成、B2B集成、自动化业务流程管理、人工流程管理、企业门户,以及对所有应用系统和流程的管理和监控等
5.企业之间的应用集成

EAI技术可以适用于大多数要实施电子商务的企业,以及企业之间的应用集成。EAI使得应用集成架构里的客户和业务伙伴,都可以通过集成供应链内的所有应用和数据库实现信息共享。也就是说,能够使企业充分利用外部资源。例如,一些企业的SCM系统可能包括交易系统,EAI技术可以首先在交易双方之间创建连接,然后再共享数据和业务过程:企业要顺利开展电子商务,可以利用EAI技术,使企业的信息系统与合作伙伴的信息系统之间能够实现无缝而及时的通信。

